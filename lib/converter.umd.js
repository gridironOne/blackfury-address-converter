!function(e,r){"object"==typeof exports&&"undefined"!=typeof module?r(exports,require("crypto-addr-codec"),require("bech32")):"function"==typeof define&&define.amd?define(["exports","crypto-addr-codec","bech32"],r):r((e||self).blackAddressConverter={},e.cryptoAddrCodec,e.bech32)}(this,function(e,r,o){const d={decoder:e=>{const o=r.stripHexPrefix(e);if(!r.isValidChecksumAddress(e,null)&&o!==o.toLowerCase()&&o!==o.toUpperCase())throw Error("Invalid address checksum");return Buffer.from(r.stripHexPrefix(e),"hex")},encoder:e=>r.toChecksumAddress(e.toString("hex"),null),name:"ETH"};function c(e){return r=>o.encode(e,o.toWords(r))}const t=(e,r)=>{return{decoder:(d=r,e=>{const{prefix:r,words:c}=o.decode(e);if(r!==d)throw Error("Unrecognised address format");return Buffer.from(o.fromWords(c))}),encoder:c(r),name:e};var d},n=t("blackvaloper","blackvaloper"),s=t("black","black");e.BLACK=s,e.BLACKV=n,e.ETH=d,e.blackfuryToEth=e=>{let r=s.decoder(e);return d.encoder(r)},e.blackvToEth=e=>{let r=n.decoder(e);return d.encoder(r)},e.ethToBlackfury=e=>{let r=d.decoder(e);return s.encoder(r)},e.ethToBlackfuryv=e=>{let r=d.decoder(e);return n.encoder(r)}});
//# sourceMappingURL=converter.umd.js.map
